---
description: For anything about auth and error handling related to the Uploadthing library
globs: 
alwaysApply: false
---
# Authentication & Security

Authentication is a vital part in protecting your app from malicious usage. In
this section we'll go over how to protect different parts of the UploadThing
flow.

<Warning>
  Do not protect the entire `/api/uploadthing` route from being called by
  unauthenticated users. The endpoint is called as a webhook by our server and
  thus must be publically available.
</Warning>

## Protecting the endpoint from spoofing

The callback request is like a webhook that is called by UploadThing when your
file has been uploaded to the storage provider. The callback data is signed
(HMAC SHA256) using the API key that uploaded the file. Since `v6.7` of the
Uploadthing SDK, the callback data is automatically verified before executing
the callback. There is no additional work needed to protect the callback
endpoint other than making sure you're on a version `^6.7` to ensure your
endpoint is appropriately protected.

## Protecting unauthenticated users from uploading files

You can protect unauthenticated users from uploading files via the
[`.middleware()`](/file-routes#middleware) function in each file route. This
makes it trivial to protect some file routes, and keep some public.

Using your favorite authentication provider (or self-roll if that's your thing),
retrieve the current user's session from the incoming request. If it's not
valid, you can throw an error which will terminate the upload flow. In the
following example, we have a public file route that is protected by rate
limiting, and a protected route that allows any authenticated user to upload
files:

```ts
import { auth } from "auth";

import { createUploadthing, UploadThingError } from "uploadthing/server";

import { RateLimit } from "~/lib/ratelimit";

const ratelimiter = new RateLimit({
  /** rules */
});

export const uploadRouter = {
  publicRoute: f({ image: {} })
    .middleware(async ({ req }) => {
      const limit = await ratelimiter.verify(req);
      if (!limit.ok) {
        throw new UploadThingError("Rate limit exceeded");
      }

      return {};
    })
    .onUploadComplete(() => {
      /** ... */
    }),

  privateRoute: f({ image: {} })
    .middleware(async ({ req }) => {
      const session = await auth(req);
      if (!session) {
        throw new UploadThingError("You need to be logged in to upload files");
      }

      return { userId: session.user.id };
    })
    .onUploadComplete(() => {
      /** ... */
    }),
};
```

<Note>
  By throwing an `UploadThingError`, the error message is automatically sent
  down to the client. If throwing other errors, you need an
  [`errorFormatter`](/concepts/error-handling#error-formatting) to control what
  is sent down to the client.
</Note>

---

# Error Handling

## Error Formatting

> Added in `v5.2`

You can customize the server-side behavior in your API handler's options by
using an error formatter.

By default, the client only receives a generic message like
`"Failed to run middleware"` to avoid leaking any sensitive information. You can
customize this behavior by specifying the `errorFormatter` option when you
initialize your file route helper. An error formatter runs on the server and
takes the original `UploadThingError`, and returns a JSON-serializable object.
The error also includes a `cause` property which contains more information about
the nature of the error and what caused the error to throw in the first place.

You can also throw an `UploadThingError` inside your middleware which will send
the error message to the client. All other error types will use a generic error
message. Regardless of what error is thrown, you can still change the defaults
with `errorFormatter`.

```ts
import {
  createUploadthing,
  UploadThingError,
  type FileRouter,
} from "uploadthing/server";

const f = createUploadthing();

const auth = (req: Request) => ({ id: "fakeId" });

export const ourFileRouter = {
  imageUploader: f({ image: { maxFileSize: "4MB" } })
    .middleware(async ({ req }) => {
      const user = await auth(req);

      if (!user) throw new Error(`Cant find user from req: ${req.toString()}`); // client onError will get "Failed to run middleware"
      if (!user.id) throw new UploadThingError("No user ID"); // client onError will get "No user ID"

      return { userId: user.id };
    })
    .onUploadComplete(async ({ metadata, file }) => {
      console.log("Upload complete for userId:", metadata.userId);

      console.log("file url", file.url);

      return { uploadedBy: metadata.userId };
    }),
} satisfies FileRouter;

export type OurFileRouter = typeof ourFileRouter;
```

### `UploadThingError`

For most users, throwing an `UploadThingError("your message")` will be enough.
For advanced use cases, you can pass an options object for more control.

```ts
type UploadThingErrorOptions<T> =
  | {
      /**
   * ERROR_CODES:
   *  BAD_REQUEST: 400,
   *  NOT_FOUND: 404,
   *  FORBIDDEN: 403,
   *  INTERNAL_SERVER_ERROR: 500,
   *  INTERNAL_CLIENT_ERROR: 500,
      
   *  // S3 specific
   *  TOO_LARGE: 413,
   *  TOO_SMALL: 400,
   *  TOO_MANY_FILES: 400,
   *  KEY_TOO_LONG: 400,
      
   *  // UploadThing specific
   *  URL_GENERATION_FAILED: 500,
   *  UPLOAD_FAILED: 500,
   *  MISSING_ENV: 500,
   *  FILE_LIMIT_EXCEEDED: 500,
   * @default `INTERNAL_SERVER_ERROR`
   */
      code?: keyof typeof ERROR_CODES;
      /**
       * Your error message describing what happened
       * @default `An unknown error occurred`
       */
      message?: string;
      /**
       * The original error that caused this, if any.
       */
      cause?: unkown;
      /**
       * Data associated with the error
       */
      data?: T;
    }
  | string;
```

If you're using Zod as an input parser, you can return information of what
fields failed validation by checking if the cause is a `ZodError`. Zod provides
a `flatten` method that returns a JSON-serializable object which we can return
to the client.

```ts
import * as z from "zod";

import { createUploadthing } from "uploadthing/next";
import type { FileRouter } from "uploadthing/next";

const f = createUploadthing({
  errorFormatter: (err) => {
    return {
      message: err.message,
      zodError: err.cause instanceof z.ZodError ? err.cause.flatten() : null,
    };
  },
});

export const uploadRouter = {
  withInput: f(["image"]).input(z.object({ foo: z.string() })),
  //  ...
} satisfies FileRouter;
```

## Catching errors on the client

You can catch errors on the client by using the `onUploadError` property on the
premade components, or the `useUploadthing` hook. You can access the JSON object
that you returned from your error formatter on the `data` property:

```tsx
<UploadButton
  endpoint="withInput"
  input={{ foo: userInput }}
  onUploadError={(error) => {
    console.log("Error: ", error);
    const fieldErrors = error.data?.zodError?.fieldErrors;
    //                              ^? typeToFlattenedError
    setError(fieldErrors.foo[0] ?? "");
  }}
/>
```